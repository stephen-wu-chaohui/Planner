@inherits ComponentBase
@inject WizardService Wizard

@namespace Planner.BlazorApp.WelcomeWizard

<div class="wizard-backdrop" style="visibility: @(Wizard.IsOpen ? "visible" : "hidden")">
    @if (CurrentStep is not null) {
        <div class="wizard-modal @AnimationClass">

            @if (!string.IsNullOrWhiteSpace(CurrentStep.ImageUrl)) {
                <div class="wizard-image">
                    <img src="@CurrentStep.ImageUrl" alt="">
                </div>
            }

            @if (!string.IsNullOrWhiteSpace(CurrentStep.Title)) {
                <h2 class="wizard-title">@CurrentStep.Title</h2>
            }

            @if (!string.IsNullOrWhiteSpace(CurrentStep.Description)) {
                <p class="wizard-description">@CurrentStep.Description</p>
            }

            @if (IsLast) {
                <div class="wizard-dontshow">
                    <input type="checkbox" id="dontShow" @bind="dontShowAgain" />
                    <label for="dontShow">Don’t show this again</label>
                </div>
            }

            <div class="wizard-dots">
                @for (var i = 0; i < Steps.Count; i++) {
                    <span class="wizard-dot @(i == Wizard.StepIndex ? "active" : "")"></span>
                }
            </div>

            <div class="wizard-controls">
                <button class="btn-secondary" @onclick="Prev" disabled="@IsFirst">Previous</button>

                @if (!IsLast) {
                    <button class="btn-primary" @onclick="Next">Next</button>
                } else {
                    <button class="btn-primary" @onclick="Finish">Finish</button>
                }

                <button class="btn-close" @onclick="Close">×</button>
            </div>
        </div>
    }
</div>

@code {
    private IReadOnlyList<WizardStep> Steps { get; } = WelcomeWizardDefinition.Steps;
    private string AnimationClass = "";
    private bool dontShowAgain = false;

    private WizardStep? CurrentStep =>
        (Wizard.StepIndex >= 0 && Wizard.StepIndex < Steps.Count) ? Steps[Wizard.StepIndex] : null;

    protected override void OnInitialized() {
        Wizard.OnChange += HandleWizardChanged;
    }

    public void Dispose() {
        Wizard.OnChange -= HandleWizardChanged;
    }

    private void HandleWizardChanged() => InvokeAsync(StateHasChanged);

    private bool IsFirst => Wizard.StepIndex <= 0;
    private bool IsLast => Steps.Count > 0 && Wizard.StepIndex >= Steps.Count - 1;

    private void Animate(string direction) {
        // direction: "next" or "prev"
        AnimationClass = direction == "next" ? "slide-in-right" : "slide-in-left";

        // force re-render with animation class
        InvokeAsync(StateHasChanged);

        // reset animation after animation duration (350ms)
        _ = Task.Delay(350).ContinueWith(_ => {
            AnimationClass = "";
            InvokeAsync(StateHasChanged);
        });
    }

    private void Next() {
        if (IsLast) return;
        Wizard.NextStep();
        Animate("next");
    }

    private void Prev() {
        if (IsFirst) return;
        Wizard.PreviousStep();
        Animate("prev");
    }

    private async Task Finish() {
        Close();
        await Task.CompletedTask;
    }

    private void Close() {
        Wizard.Close();
    }
}
